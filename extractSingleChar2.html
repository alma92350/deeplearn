<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<script src="montreal_files/deeplearnlatest.js"></script>
<script src="singleCharGenerator1.js"></script>
<script src="capSingleModel2.js"></script>
</head>

<body>
  <canvas id="canvas_ori"></canvas><br>
  <canvas id="canvas_out"></canvas><br>
  <canvas id="canvas_out2"></canvas><br>
  
  <div>
  <input id="generatebtn" value="Generate" onclick="generate()" type="button">
	<input id="loadbtn" value="Load" onclick="load()" type="button">
	<input id="trainbtn1" value="Train (initial)" type="button">
	<br>
	<input id="predictbtn" value="Predict" type="button">
	<input id="trainbtn2" value="Train (wrong)" type="button">
	<input id="trainbtn3" value="Train (probability)" type="button">
	<br>
	<input id="runbtn"   value="RUN"   onclick="Scheduler.run()"    type="button">
	<input id="pausebtn" value="PAUSE" onclick="Scheduler.pause()"  type="button">
	<input id="stopbtn"  value="STOP"  onclick="Scheduler.stop()"   type="button">
	<br>
	<input id="initbtn"  value="INIT"  onclick="initialize()" type="button">
	<input id="savebtn"  value="Save"  onclick="saveModelVariablesToLocalStorage()" type="button">
	<input id="restorebtn"  value="Restore"  onclick="restoreModelVariablesFromLocalStorage()" type="button">
  </div>
  <br>
  <img id="image_ori" src=""><br>
  <input id="webSocket" type="text" size=20 placeHolder="Address to a websocket">
  <input id="reportbtn"  value="Init Report" onclick="report.init()" type="button">
  <br>
  <input id="input_label" type="text" size=5 value="90">
	<label id="lab_count">0</label>
  <div   id="div_results"></div>
  <div   id="div_predictions"></div>
</body>

<script>
var inputImageDataStack = [];
</script>
<script src="extractSingleChar2.js"></script>

<script>
//////////////////////////////////////////////////////
/////////// Filter Focus solution ////////////////////
//// build the filters from the char set         /////
//// use conv and filters to detect the char set /////
//////////////////////////////////////////////////////
var ff = {
	ctx : document.getElementById("canvas_ori").getContext("2d"),
	ctxOut : document.getElementById("canvas_out").getContext("2d"),
	scores : [],
	ys : [],
	dl_layers:[],
};
function drawLocation(layer0){
	var center_x = layer0.max([1]).argMax().dataSync()[0];
	var center_y = layer0.max([2]).argMax().dataSync()[0];
	var score    = layer0.max().dataSync()[0];
	
	//ff.ctxOut.strokeStyle="#FFFFFF";
	//ff.ctxOut.strokeRect(center_x-11,center_y-11,21,21);
	//ctx.strokeRect(0,0,21,21);
	return {x:center_x, y:center_y, score: score};
}

function nMaxOf(arr,n=5){
	var newArray = Array.from(arr,(x,i)=>{return {idx:i,val:x};});
	console.log(newArray);
	var localMax=[];
	for(var i=1;i<newArray.length-1;i++){
		if(newArray[i-1].val<newArray[i].val && newArray[i+1].val<newArray[i].val){
			localMax.push(newArray[i]);
		}
	}
	console.log(localMax);
	var sortedMax = localMax.sort((a, b)=>{return (b.val-a.val)});
	return sortedMax;
}
function findCharXLocations(){
	var idxs = [];
	for(var i=0; i<ff.scores[0].length;i++){ // 100
		var someMax=0;
		for(var j=0;j<ff.scores.length;j++){ // 75
			//find max
			if(ff.scores[j][i]>someMax) 
				someMax = ff.scores[j][i];
		}
		//console.log(someMax);
		var conv=1;
		for(var j=0;(someMax!==0) && (j<ff.scores.length);j++){
			conv *= ff.scores[j][i]/someMax;
		}
		//console.log('i: ' + i + 'conv: ' + conv);
		idxs.push(someMax==0?0:conv);
	}
	
	return idxs;
}

function testAllChar(){
	//var value = createTestImage()-(3000*255);
	
	filterFocus.initialize();
	filterFocus.makeInputXs();
	
	for(var i=0;i<iDataStack.length;i++){
		var value = 0;
		for(var j=0;j<(21*21*4);j++){
			value += iDataStack[i].data[j];
		}
		
		console.log(iDataStack[i].label + ': ' + (value-255*21*21)/3/255);
	}
	
	ff = {
		ctx : document.getElementById("canvas_ori").getContext("2d"),
		ctxOut : document.getElementById("canvas_out").getContext("2d"),
		scores : [],
		ys : [],
		dl_layers:[],
	};
	
	ff.ctx.beginPath();
	for(let label of _LABELS){
		if(label!=='none')
			test(label);
	};
	
	var top5 = nMaxOf(findCharXLocations()).slice(0,5);
	console.log(top5);
	for(var i=0; i<5; i++){
		ff.ctxOut.strokeStyle="#FFFFFF";
		ff.ctxOut.strokeRect(top5[i].idx-11,1,21,29);
	}
	ff.ctx.closePath();
	
	ff.ctxOut.beginPath();
	
	ff.ctxOut.closePath();
};

function test(target){
	//var value = createTestImage()-(3000*255);
	
	//filterFocus.initialize();
	
	//filterFocus.makeFilters(target);
	for(var i=0;i<iDataStack.length;i++){
		var data = iDataStack[i];
		
		if(data.label == target){
			filterFocus.makeAFilter(data);
			console.log('made a filter');
			var layer0 = filterFocus.model(filterFocus.inputXs);
			console.log('layer0 computed');
			var loc = drawLocation(layer0);
			
			ff.dl_layers.push(layer0);
			ff.scores.push(Array.from(layer0.max([1]).dataSync()));
			ff.ys.push(Array.from(layer0.max([2]).dataSync()));
			
			console.log(target + ': x: ' + loc.x + ', y: ' + loc.y +' score: ' + loc.score); 
		}
	}
	
	//filterFocus.makeInputXs();
	
	
}

function createTestImage(){
	var width = 100;
	var height = 30;
		
	const inpLabel =  document.getElementById("input_label");
	const label = inpLabel.value;
	
	ff.ctx.fillStyle="black";
  ff.ctx.fillRect(0,0,width,height);
  
	ff.ctx.font = FONT;
	
	ff.ctx.fillStyle="white";
  ff.ctx.fillText(label,5,20);
  inputImageDataStack = [ff.ctx.getImageData(0,0,width, height)];
  
  var value=0;
  for(var i=0;i<12000;i++)
  	value += inputImageDataStack[0].data[i];
  
  return value;
  //console.log('display value: ' + (value/255));
}

// get image from inputImageDataStack using the Target elements
// create a filterStack
var filterFocus = {
	filterStack : {},
	INPUT_IMAGE_WIDTH: 100,
	INPUT_IMAGE_HEIGHT: 30,
	STRIDES_1: 1,
};

filterFocus.makeAFilter = function(data){

	filterFocus.filterStack = dl.tidy(() => {
			return makeTensorFromPixels(data); //xs[1]; //dl.stack(xs,2); //
		});
};

filterFocus.makeFilters = function(target){
	var xs = [];
	for(var i=0;i<iDataStack.length;i++){
		var data = iDataStack[i];
		
		if(data.label == target){
			xs.push(makeTensorFromPixels(data));
		}
	}

	filterFocus.filterStack = dl.tidy(() => {
			return xs[1]; //dl.stack(xs,2); //
		});
};

filterFocus.makeInputXs = function(){
	var xs=[];
	for(var i=0 ;i<inputImageDataStack.length;i++){
		var data = inputImageDataStack[i];
		xs.push(makeTensorFromPixels(data).as2D(filterFocus.INPUT_IMAGE_WIDTH, filterFocus.INPUT_IMAGE_HEIGHT));
	};
	filterFocus.inputXs = dl.tidy(() => {
			return xs[0]; //dl.stack(xs,0);
		});
}

filterFocus.initialize = function(){
	filterFocus.INPUT_IMAGE_WIDTH = inputImageDataStack[0].width;
	filterFocus.INPUT_IMAGE_HEIGHT = inputImageDataStack[0].height;
	
}

// compute convolution over the input image for each filter
filterFocus.model = function(inputXs) {	//: dl.Tensor2D : dl.Tensor2D
  const xs = inputXs.as4D(-1, filterFocus.INPUT_IMAGE_HEIGHT, filterFocus.INPUT_IMAGE_WIDTH, 1);

  const strides1 = filterFocus.STRIDES_1;
  const pad1 = 0;

  const layer1 = dl.tidy(() => {
    return xs.conv2d(filterFocus.filterStack.as4D(CANVAS_SIZE,CANVAS_SIZE,1,1), 1, 'same');
        //.relu();
        //.maxPool([2, 2], strides1, pad1);
  });
  
  return layer1;
}

// display the resulting vector
 

</script>

